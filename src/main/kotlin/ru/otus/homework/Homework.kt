package ru.otus.homework

import kotlin.random.Random
import kotlin.system.measureTimeMillis

fun main() {
    // ## 1. Функция с обязательными и необязательными позиционными параметрами
    println(summArguments(1, -1, 1, -1, 1, -1))
    // ## 2. Функция с необязательным параметром и позиционными параметрами
    println(concatStrings("aa", "bb", "cc", "dd"))
    println(concatStrings("aa", "bb", "cc", "dd", arg2 = '!'))
    // ## 4. Функция, измеряющая время выполнения другой функции
    leadTime(::randomTimeRun)
}

// ## 1. Функция с обязательными и необязательными позиционными параметрами
// Напишите функцию, которая будет принимать:
//  - два обязательных аргумента типа `Int`
//  - неограниченное число дополнительных аргументов типа `Int`
// Функция должна возвращать сумму первого, второго и дополнительных аргументов.
// Если в функцию передано меньше двух аргументов, программа не должна собираться (ошибка компиляции).
fun summArguments(arg1: Int, arg2: Int, vararg arg3: Int): Int = arg1 + arg2 + arg3.sum()

// ## 2. Функция с необязательным параметром и позиционными параметрами
// Напишите функцию, которая будет принимать:
// - неограниченное количество строк `String`
// - необязательный параметр типа `Char`
// Функция должна возвращать объединение строк.
// - по умолчанию, строки объединяется пробелом
// - если передан `Char` параметр, то объединение делается этим символом
fun concatStrings(vararg arg1: String, arg2: Char = ' '): String = arg1.joinToString(separator = arg2.toString())

// ## 4. Функция, измеряющая время выполнения другой функции
// Напишите функцию, которая бы принимала другую функцию в качестве параметра.
// Ваша функция должна запустить функцию, переданную в аргументе, и вернуть время ее выполнения.
// Примечание: используйте что-то долгое (например, длинный цикл с печатью) в качестве тестовой функции. Иначе, вы можете
// не заметить, сколько времени прошло
fun leadTime(arg1: () -> Unit) {
    println("Время выполнения " + measureTimeMillis { arg1() } + "ms")
}

fun randomTimeRun() {
    Thread.sleep(Random.nextLong(1000, 5000))
}